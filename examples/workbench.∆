
# [3 4 + 4 5]

# get_list = \v
# 	[v*1 v*2 v*3]

# 3 | get_list

# @foreign map = \list: List[T] f: Function[T] => F => List[F]
# foreach elm in list: f(elm)

# sum = \list
# 	result = 0
# 	list | map \v
# 		result = result + v
# 	result

# [3 5 7] | sum

# [3 5 6] | index 1
# [3 5.4 6]

# [3.3 5.4 6.5] | List.get 1

# List.get = \list: List[T] index: int => T
# List.get = \list index
# 	@native list_get_element_at_index index

# --------

# [3.3 5.4 6.5] | get_list_element_at_index 1

# --------

# [3.3 5.4 6.5] | get_array_length

# --------

# map = \list fn
# 	len = list | get_array_length
# 	loop = \acc i
# 		("acc {i}") | log
# 		i is
# 			_ if i == len
# 				acc
# 			_
# 				mapped = list | get_list_element_at_index i | fn
# 				(acc | append mapped) | loop (i + 1)

# 	base = [0]
# 	base | loop 0

# [3, 4, 5] | map \x
# 	x * x

# --------

# map_one = \list i fn
# 	(list | get_list_element_at_index i) | fn

# [3, 4, 5] | map_one 1 \x
# 	x * x

# --------

# map_one = \fn
# 	list = [3, 4, 5]
# 	elm = list | get_list_element_at_index 1
# 	elm | fn

# f = \x
# 	x * x

# f | map_one

# --------

# # works
# map_one = \list fn
# 	list | get_list_element_at_index 1 | fn

# f = \x
# 	x * x

# [3, 4, 5] | map_one f

# --------

# # does not work
# map_one = \list i fn
# 	list | get_list_element_at_index i | fn

# f = \x
# 	x * x

# [3, 4, 5] | map_one 1 f

# --------

# [3, 4, 5] | append 6

# --------

# repeat = \fn i
# 	i is
# 		_ if i > 0
# 			i | fn
# 			fn | repeat (i - 1)

# hello = \i
# 	"hello #{i}"

# hello | repeat 3

# --------

# rec = \v
# 	v is
# 		n if n > 0
# 			("rec: {v}") | log # Works with parenthesis, not without
# 			x = v - 1
# 			x | rec
# 		_
# 			v

# 2 | rec

# sum_loop = \list i value
# 	len = list | get_array_length
# 	new_value = value + (list | get_list_element_at_index i)
# 	i is
# 		_ if i == len - 1
# 			new_value
# 		_
# 			list | sum_loop (i + 1) new_value

# Listsum = \list
# 	# len = list | get_array_length
# 	# sum_loop = \i
# 	# 	value = value + (list | get_list_element_at_index i)
# 	# 	i is
# 	# 		len
# 	# 			value
# 	# 		_
# 	# 			(i + 1) | sum_loop
# 	# 0 | sum_loop
# 	list | sum_loop 0 0

# ----------

# Listsum2 = \list
# 	len = list | get_array_length
# 	value = 0
# 	sum_loop = \i
# 		value = value + (list | get_list_element_at_index i)
# 		i is
# 			_ if i == len - 1
# 				value
# 			_
# 				(i + 1) | sum_loop
# 	0 | sum_loop

# [3, 4, 5] | Listsum2

# [4, 3, 2]

# Long term syntax?
# data Position
# 	x f32
# 	y f32

# pos = Position
# 	x: 2.3
# 	y: 3.4

# Short term syntax?
component Position { x f32, y f32 }
component Velocity { dx f32, dy f32 }
pos = Position { y 2.3, y 4.5 }
vel = Velocity { dx 1.0, dy 0.5 }

print_vel = \v
	v | log

vel | print_vel
pos | print_vel

# for Position p, Velocity v in ∆
# 	p += v

# component Player {
# 	p Position
# 	v Velocity
# }

# ∆(Player p)
# 	p.p += p.v

# ∆(Position p, Velocity v)
# 	| each(.p = )

# TODO(anissen): How to differentiate mutation of ∆ from simply creating a new ∆?
# ∆ = ∆(Position p, Velocity v)
# 	| map(.p += .v)

# ∆(Position p, Velocity v)
# 	p += v

# entities = ∆(Position p, Velocity v)

# entities
# 	| each
# 		.p += .v
